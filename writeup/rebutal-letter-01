Dear Reviewers and PC Members,

Firstly, we would like to thank you for the useful feedback you gave us.

From distilling the reviews, we see that there is an overall feeling
that section 4 could benefit greatly from the addition of 
an example oracle for Tree23. We'd be happy to add this for the final version.

Reviwer A and B question the importance of the generic implementation.
Our main contribution with this paper is the representation of patches
and the algorithm. That being said, the generic implementation is *also*
an important contribution. For one it enabled us to get the empirical results.
But more importantly, there are non-trivial techniques that must take place
to keep the implementation efficient. One example is how the
generic implementation works over trees annotated with their hashes. (line 925)

Next, we address the other important points raised by the reviewers inline.

Naturally, we are happy to address all the minor
points raised by the reviewers for a final version.

A>  1. Your definition of closed patches rule out the deletion of subtrees, i.e. a change
A> 
A>         (Node2C 0 1, Node2C 0 LeafC)
A> 
A>     would not be allowed. This seems a bit odd, in particular if it suddenly
A>     becomes allowed if the deleted subtree occurs at some unrelated part of the
A>     output tree:
A> 
A>         (Node2C (Node2C 0 1) 1, Node2C (LeafC 0 LeafC) 1)
A> 
A>     How much would users be surprised by that?

There seems to be a misunderstanding here. 
Firstly, deletions are represented by:

        (Node2C 0 t, Node2C 0 LeafC)

Since t is not shared its not assigned a metavariable.
For the second part, the algorithm maximizes sharing even
when subtrees are deleted. We can imagine use cases when this is
desirable, i.e., inlining a method in multiple places while deleting the original method
definition.

Notwithstanding, as discussed in line 1137 (Future Work), we are interested in
researching how to better control sharing, limitting unexpected behaviors.

A>  2. I found the need for minimizing changes (section 2.3) is not
A>     well-motivated, especially as it not only reduces the size of the diffs (which
A>     is nice, but not critical), but changes the semantics of a patch. Before
A>     minimizing. It changes a change like
A> 
A>         (Node2C (Node3C t1 1 2) (Node3C t2 1 2), Node2C (Node3C t3 2 1) (Node3c t4 2 1))
A> 
A>     where we swap subtrees in two positions, assuming they are identical, to
A> 
A>         (Node2C (Node3C t1 1 2) (Node3C t2 3 4), Node2C (Node3C t3 2 1) (Node3c t4 4 3))
A> 
A>     where we now still do the same swapping, but the subtrees do not have to be
A>     related.

Minimizing changes does /not/ introduce new variables. In fact, the change illustrated
above,

 (Node2C (Node3C t1 1 2) (Node3C t2 1 2), Node2C (Node3C t3 2 1) (Node3c t4 2 1))

Is already in minimal form. The closure function would return this without further modifications.

The only reason for minimizing changes is to help merging. We are happy
to clarify this.

A>  4. You write “Yet, storing all revisions of every file under version control
A>     is clearly not an acceptable solution.” This has been proven false with
A>     great success by git, which does simply store all files of all revision.
A>     (There is some compression happening later, but it does *not* store diffs!)

You are correct. Thanks for spotting this. The problem remains that storing
patches as pairs is not ideal. There is obvious apply function that works
on more than one input.

A>  6. In your merge implementation, can you do a partial merge while leaving some
A>     form of conflict markers in the files that tell the developer what they
A>     have to resolve? (Presumably not easily, as you are bound to the particular
A>     typed AST...)

Our merge implementation already does that. It returns a patch with the conflicts
in place. We can see this on the return type of merge:

type PatchConf codes = Tx codes (Sum (Conflict codes) (Change codes))

The outermost Tx represents the 'spine' to be copied from source to destination.
This spine will have either changes or conflicts on its leaves.

B> The proposed approach can be regarded as a grammar-based tree
B> compression of a pair of the source and destination.  Grammar-based
B> (tree) compression is a method of compressing data by representing the
B> data as a context-free (tree) grammar.
B> 
B>   Markus Lohrey:
B>   Grammar-Based Tree Compression.
B>   DLT 2015: 46-57

Thanks for point that out, we did not know about Grammar-Based Tree
Compression.  There is a misunderstanding here. Lets look at
an example. Consider both source and destination to be the same.

src = t = dst

Now, if we apply GBTC to (t , t), we would obtain a more
space-efficient representation of it, but we would not be apple to
apply the resulting patch to any trees other than t.

In fact, this implementation does not satisfy the property that apply
(diff t t) x == just x for any x. (line 62).

We will add it to our list of related work and put a comparisson of the
approaches on the paper. 

B> From this viewpoint, the proposed implementation is quick-and-dirty.
B> In step (1), only subtrees are shared; then, in step (2), only a
B> context that start from the root node is shared. Again, while I
B> appreciate the simplicity of the current approach, I suspect that the
B> obtained patches can be far larger than the optimal.  It is natural to
B> conjecture that the non-optimality is not problematic in practice.
B> Nevertheless, this conjecture should be supported by experiments.

We have not presented a notion of optimal patch in this paper and
do not understand what you mean by it.

We are not striving to represent two trees (source and destination)
in the most space-efficient way. Our objective here is to
compute a transformation that maps the source to the destination,
but can be applied to as many trees as possible. See the example above.

C> L44: "using xml or json […] a patch may produce ill-typed results." Do
C> you mean ill-balanced? or schema violations?

Schema violations. There is no guarnatee that the result of applying
a patch will adhere to the correct xml schema. This is specially problematic
after manipulating patches as first order objects: how do we know
the resulting patches are still producing valid AST's?

C> L382: "In the worst case, the resulting spine will be empty—but the
C> change will certainly be closed." that's because of
C> post-process. Could post-process have been merged with closure?

Yes. They can be made into the same function, but it is a fairly convoluted
function. We chose to keep it separate for the sake of presentation.

C> Related work: The authors should relate their work to incremental
C> parsers and how these represent changed trees (see for example the
C> work by Wagner and Graham).

Thanks for pointing this out. We were unaware of the work of Wagner and Graham.
We are happy to add a comparison in our final version.

C> Paper title: The paper didn't explain what makes the presented
C> algorithms "type-directed". I understand that the algorithms consume
C> and produce data belonging to a datatype, but I couldn't see where the
C> algorithm is directed by the type of the tree. Wouldn't it be more
C> precise to say that the produced patches are type-safe?

We are happy to change the title to "type-safe" instead. It
is more precise, indeed.

