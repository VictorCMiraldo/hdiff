
A> Review #82A (C , Z)
A> ===========================================================================
A> Paper summary
A> -------------
A> The authors present an algorithm to summarize the the differences between two
A> typed trees (e.g. ASTs, other generic first-order data structures). In contrast
A> to earlier approaches to tree diffing, which minimize the number of tree
A> operations to go from one to the other, this approach represents the patch as a
A> rewrite system with a single rule, matching on the incoming tree and describing
A> the output tree.

This is more or less accurate. The big difference from previous work is our 
hability to handle contractions and arbitrary permutations.

A> I find generic diffing and merging a fascinating topic, and enjoyed reading
A> about the algorithm proposed by the authors. It is surprisingly obvious and
A> simple! That’s good.

Just like reviewer #82B, we also agree that the simplicity is a plus.

A> I was less happy about section 3: after you outlined the algorithm with a
A> example in section 2, section 3 did not offer much more than “and now we do the
A> same generically”, which I have no doubt is a notable feat, and would make a
A> great tutorial or workshop, but is not per se interesting to read about. Can
A> you more clearly identify the challenges that you were facing, and how you
A> solved them, and what we can learn from that?
A> 
A> ## Scope
A> 
A> Overall, I am a bit unsure about the focus of the paper.
A> 
A>  * Is the diff algorithm the main contribution? Then Section 3 is too long,
A>    Section 4 deserves a treatment that is not tied to the generic programming
A>    aspect, and there is a lot missing in discussing the diff algorithm itself,
A>    its relation to other algorithms, design choices in the algorithm (see below
A>    for some open questions). If this is really a novel approach, and treated
A>    properly, this would make a great paper.
A> 
A>  * Or, is the generic programming the main contribution? In that case, the
A>    paper is nicely done, but may fall short of a ICFP research paper, as it
A>    seems it is “just” a neat application of generic programming. Maybe it could
A>    be an Experience Report?
A> 
A> In either case, I think the paper needs more work before it can be accepted.

We understand how the current presentaion might obscure the main focus of 
our paper. The main contribution is the diffing algorithm itself. We would be
happy to shorten section 3 and expand on the algorithm.

That being said, we believe that the generic programming aspect of it is
also a valid contribution. Note that it is only because it could be implemented
generically that we could evaluate our work with real examples.

A>     Presumably, having the patch apply to *more* inputs is a good thing, but
A>     Section 2.3 does not contain any significant discussion of this (besides
A>     “This keeps changes small and isolated”.) If the algorithm is the main focus
A>     of the paper, then this deserves more discussion, in particular propositions
A>     like “a minimizing a patch only extends its domain, and does not change its
A>     effect on the domain of the original patch”.

We agree and would be happy to expand on the theme.

A>  3. In Section 4 I am missing a discussion of how to hash the data in the tree,
A>     but this may be due to my limited knowledge about generic programming.
A>     Shouldn't there be some type-class constraints somewhere that ensure that the
A>     leafs of the data type support an `encode` function?

We agree that section 4 could have been longer. After reading the reviews we agree
with the general feeling that section 3 is too long and section 4 should show how
to handle Tree23, as in section 2. We are happy to implement these changes
for the final version.

Yes, you are correct, we did omit the constraint on encode in an attempt to simplify
that code. Our plan to expand on section 4 will fix that.

A>  5. Re evaluation: What constitutes a “conflict” (line 1071). Conflicts are not
A>     a native concept in Git... so presumably you looked at all merge commits,
A>     and tried to recreate the merge uthem sing a naive `git merge` command, and
A>     checked if that succeeds? Please be more precise there. (You hint at
A>     `diff3` in line 1133, but more details would be welcome.)

You are right, we considered as conflict all the triples (A , O , B) of files
in the merge commits that git marks as "unmerged". This is essentially where
the command line tool would ask for human intervention.

A>     BTW, did you know that even when a Pull Request is merged using rebase or
A>     squash on GitHub, the `refs/pulls/123/head` reference (i.e. a hidden
A>     branch) is still available and refers to the state before the rebase/merge.
A>     You might find more interesting merge commits on these branches.

That's very interesting! We did not know that! 

A> ## Minor comments
A> 
A> line 50: missing space after comma after “Patch”
A> 
A> line 76: Use ’ not ‘ to close the quotes.
A> 
A> line 632: Why are you using a state monad when it looks like a reader monad
A> would suffice? In fact, why are you using a monad when it seems you could just
A> pass a fixed set of `okvars` down? Maybe I am missing something, in that case,
A> please explain better.
A> 
A> line 684: unresolved reference (??)
A> 
A> line 917: missing period after “subtree”.
A> 
A> line 1068: missing noun after “empirical”
A> 
A> Section “future work“: I think you can cut this down. It is a nice wishlish,
A> but doesn’t really contribute to the paper.


B> Review #82B (C , Y)
B> ===========================================================================
B> 
B> Paper summary
B> -------------
B> This paper proposes a datatype-generic tree "diff" algorithm. The
B> algorithm is implemented by using the generics-mrsop library and
B> evaluated on modifications for Lua programs.

This summary is incomplete. The main contribution is not datatype-generic tree "diff",
but a linear algorithm for doing so.

B> Comments for author
B> -------------------
B> [evaluation]
B> 
B> Pros:
B> - A tree diff algorithm is an important research topic, and a
B>   datatype-generic implementation is particularly suitable for ICFP.
B> - The proposed algorithm was evaluated on practical test cases.
B> 
B> Cons:
B> - From a purely algorithmic viewpoint, the proposed algorithm is not
B>   very interesting (more discussions will be given below).
B> - The evaluation seems weak. I recommend the authors to measure not only
B>   elapsed times but also sizes of patches.

We have this data available. And the size of patches is always less than
the sum of the sizes of source and destination. We are happy to add
this data to our evaluation section.

B> While I would appreciate the proposal as a practical alternative to
B> existing diff methods, I also felt that the proposal does not contain
B> a strong academic contribution.
B> 
B> The algorithm consists of the following two major steps.
B> (1) Share subtrees common in the source and the destination and obtain
B>     two contexts (trees with variables).
B> (2) Anti-unify the obtained two contexts.
B> From an algorithmic perspective, the most interesting issue is a method
B> of specifying common subtrees. The current proposal uses hash values of
B> subtrees. Though I agree practical usefulness of this approach, from
B> a pure algorithmic view, the approach is not interesting.

B> Other parts of the proposed algorithm is rather simple. The simplicity
B> is of course a merit. Because of the simplicity, a datatype-generic
B> implementation can be obtained. In fact, I less appreciate the
B> datatype-generic implementation, which seems nearly straightforward,
B> than the simplicity of the algorithm.

We agree that the simplicity is a merit. In fact, we would argue that
the simplicity is an academic contribution.


Nevertheless, it seems like grammar
based compression is applicable to reduce the size of the patches.
This is interesting!

B> [minor issues]
B> I recommend the author(s) to mention similarity between the proposed
B> algorithm and grammar-based compression and anti-unifications.
B> 
B> In Section 2.2, the reference of "Hole 1" in Fig. 3 is regarded as a
B> bug.  However, I think it is a better result because it may provide a
B> smaller patch, if the dangling reference is resolved, especially when
B> "Hole 1" appears more than once.  Note that grammar-based compression
B> can in general introduce this kind of references.
B> 
B> p6., correctness and preciseness:
B> While they refer to diffTree23, diffTree23 is not introduced yet.
B> 
B> p14., last paragraph:
B> A strange "??" exists.
B> 
B> p23. last paragraph:
B> "one might expect expect" --- remove one "expect".


C> Review #82C (A , Y)
C> ===========================================================================
C> 
C> The paper presents a generic structural
C> diffing algorithm for tree-shaped data, computing how one tree can be
C> changed into another one. While previous approaches represent a tree
C> change as a collection of modifications, this paper proposes a new
C> representation for tree changes: A pair of tree patterns matching the
C> old and new tree, respectively, plus a store of shared trees
C> referenced in the tree patterns. By externalizing the shared trees in
C> a store, this representation can efficiently encode arbitrary tree
C> permutations. The paper goes on to optimize the change representation
C> by also factoring out identical nodes along the spine to an actual
C> change. The diffing algorithm is parameterized by an oracle for
C> identifying shared subtrees; the paper provides a time-efficient and
C> space-efficient instance based on cryptographic hashes.

This summary is accurate.

C> This was a very pleasant read
C> and I appreciated many things about this paper:
C> 
C> - Important topic: `diff` is one of the cornerstones of modern code
C>   management. Improving its precision can yield significantly better
C>   user experiences in a broad range of development tools.  

C> - Novel solution: The paper opposes the standard approach of representing a
C>   change as a collection of modifications. The example in the
C>   introduction clearly demonstrates the shortcomings the standard
C>   approach inherently has: it cannot represent tree permutation, where
C>   subtrees have been moved around. To me, the new representation of
C>   changes (and patches) is the most important contribution of the
C>   paper. The algorithms are to quite some extent determined by that
C>   change representation.  

We agree. The most important contribution is the new representation for
structured patches. The algorithms follow quite naturally once one
adopts that representation for patches.

C> - Clear explanation: Section 2 was instrumental for getting to know the proposed 
C>   approach. Section 3 shows how it can be generically realized for arbitrary 
C>   families of mutually recursive algebraic data types. Only for Section 4 I was
C>   missing a more high-level introduction, maybe following the example
C>   of Section 2 again. I strongly recommend to amend Section 4 in this
C>   regard.  

We agree, and it is in line with Reviewer #A. We are happy to expand on
section 4 by implementing the oracle for Tree23, just like section 2 implements
the algorithm for Tree23 and section 3 generalizes.

C> - Performance evaluation: The paper not only presents the
C>   solution in detail but also includes an empirical evaluation of the
C>   algorithm's performance. While the evaluation leaves quite a bit to
C>   be desired (see below), the evaluation plays a big part in
C>   demonstrating the practicality of the proposed solution.
C> 
C> For me this paper clearly should be accepted at ICFP'19. I collected
C> the following questions and comments to help the authors improve the
C> paper further:
C> 

C> L68: "Yet, storing all revisions of every file under version control
C> is clearly not an acceptable solution." not so clear to me why that
C> would be unacceptable

Answered with reviewer #A. We were not aware that that's exactly what git did.

C> Sec 1: I appreciate the correctness criteria. But diffing is maybe
C> better formulated as an optimization problem? The most important
C> property seems to be a notion of precision for diverging changes: Let
C> `B` be the base version, `C1` and `C2` be two changed versions. Then
C> we want `(diff B C1)` and `(diff B C2)` to commute as often as
C> possible: `apply (diff B C2) (apply (diff B C1) B) = apply (diff B C1)
C> (apply (diff B C2) B)`.

This is an interesting way of looking into this. We would have to change that
property slightly, as changes are rarely imediatly commuting. 

C> At the end of Sec 2.1 I was wondering how a change from `Node2 a b` to
C> `Node3 a b c` would look like, i.e., how a changed node looks like? Of
C> course this became clear, but maybe it is worthwhile to help the
C> reader by adding to (or replacing) the example of Figure 2?

We plan on adding more illustrations earlier on.

C> L321: "When x and y resemble one another these contexts may store a
C> great deal of redundant information as many constructors appearing in
C> both contexts will be ‘deleted’, and then ‘inserted’."  This is quite
C> abstract without an example.

The illustrations we want to add would make this clear.

C> L336: "Note that the changes encompass only the minimum number of
C> constructor necessary to bind and use all metavariables." unclear

We should have phrased it more directly: "Changes are the smallest
possible trees that are closed with respect to the metariables declared inside"

C> L917: "Looking up whether a tree x is a subtree of some tree s can be
C> done by looking up x’s topmost hash, also called the merkle root,
C> against the trie generated from s." Explain: Why is comparing to the
C> root only meaningful? Why is it not necessary to do a regular trie
C> lookup?  What is the integer associated to the hash? How to make sure
C> the two tries agree on that integer?

Our expansion of section 4 will answer all of this questions.
The gist of it is that the topmost hash depends on all the hashes
of all the subtrees, hence, it identifies that tree as a whole.

C> L955: "The same subtree might appear in different places in s and d,
C> for the Int associated with it will differ from mkSharingTrie s′ and
C> mkSharingTrie d′." unclear

Again, a more detailed section 4 will addres the whole construction.

C> L962: "When using a cryptographic hash, the chance of collision is
C> negligible and we chose to ignore it." Citation needed.

We will add the citation.

C> L967: "In the past, structural merging has proven to be a difficult
C> task [23, 30] even for the easiest cases."  summarize why

We are happy to add a summary for the final version.

C> L1068: The authors don't discuss the performance requirements for
C> diffing algorithms in practice. A ballpark comparison to textual diff
C> tools would greatly help put the performance numbers into context.

This is indeed lacking. We will add said comparison.

C> L1077: The result that structural diffing is more precise than textual
C> diffing is very unsurprising; this is by construction or not? The
C> experiment still provides very important data (and that should be
C> advertised more strongly): 90% of textual merge conflicts are
C> non-trivial, i.e., more than reformatting. A structural diff may be
C> the first step toward semantic merging.
C> 
C> L1120: "Firstly, we are diffing and merging abstract syntax trees,
C> hence ignoring comments and formatting" I agree this is a significant
C> threat to validity, both for performance and merge precision.
C> 
C> Future work: Another interesting challenge for future work is tree
C> sharing across files, for example, when moving a function from one
C> module to another one.

That's an interesting feature. We could think of sharing the
"is-common-subtree" oracle through a whole repository.

